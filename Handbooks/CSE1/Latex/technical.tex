\part{Technical description}
\chapter{Hardware}
\section{Introduction to CSE1}
The CS Enterprise I was initially bought in 2009, as a fully configured model boat named "Aziz" built by Model Slipway. Due to requirements for master and PhD experiments, the model was refitted by \cite{Skaatun2011}. The work performed on CS Enterprise I include, but is not limited to, dynamic positioning systems, maneuvering systems and path following, and navigation with virtual reality.

The vessel is a 1:50 scale model of a tug boat, and is fitted with two Voith Schneider propellers(VSP) astern and one bow thruster(BT). The main dimensions of the vessel are:
\begin{table}[h!]
	\caption{Main dimensions of CSE1}
	\centering
	\begin{tabular}{cc}
		\hline
		LOA & 1.105[m]\\
		B & 0.248 [m]\\
		$\Delta$ & 14.11 [kg]\\\hline
	\end{tabular}
\end{table}

\subsection{Literature}
The development of CSE1 is a product of much research from several theses, which contain complementary information on the theory applied to the system. 
\subsubsection{Journals and conferences}
\begin{itemize}
	\item LOS guidance for towing an iceberg along a straight-line path \citep{OrstenNorgrenSkjetne2014}
\end{itemize}
\subsubsection{Specialization projects and master theses}
\begin{itemize}
	\item Development of a DP system for CS Enterprise I with Voith Schneider thrusters. \citep{Skaatun2011}
	\item Development of a modularized control architecture for CS Enterprise I for path-following based on LOS and maneuvering theory \citep{Tran2013}
	\item Automatic Reliability-based Control of Iceberg Towing in Open Waters \citep{Orsten2014}
	\item Line-Of-Sight-based maneuvering control design, implementation, and experimental testing for the model ship C/S Enterprise I.\citep{Tran2014}
	\item Remote Control and Automatic Path-following for C/S Enterprise I and ROV Neptunus \citep{Sandved2015}
	\item Marine Telepresence System \citep{Valle2015}
	\item Nonlinear Adaptive Motion Control and Model-Error Analysis for Ships-Simulations and MCLab experiments \citep{bjorne2016nonlinear}
	\item Low-Cost Observer and Path-Following Adaptive Autopilot for Ships \citep{mykland2017}
\end{itemize}
\subsubsection{Other}
\begin{itemize}
	\item YouTube video \citep{Skaatun2014}
\end{itemize}

\section{Actuators}
Figure \ref{fig:position_of_actuators} illustrate the position of the actuators, and their distance from CO is given in Table \ref{tab:thruster_distance}. The BT and VSP motor speeds are controlled by an Electronic Speed Control(ESC). The ESC receive their setpoints as pulse-width modulated (PWM) signals from the cRIO digital output module. The VSP blade pitches are controlled by servos. The servos also receive their setpoint as PWM signals.

\begin{minipage}{\textwidth}
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=\linewidth]{fig/actuators_overview.png}
		\captionof{figure}{Position of actuators. Adapted from \cite{Valle2015}}
		\label{fig:position_of_actuators}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\begin{tabular}{ccc}
		\hline
		\textbf{Parameter} & \textbf{Symbol} & \textbf{Value}[m]\\\hline
		x length to VSP & $L_{x,VSP}$ & -0.4574\\
		x length to BT & $L_{BT}$ & 0.3875\\
		y length to VSP & $L_{y,VSP}$ & 0.055\\\hline
		\end{tabular}
	\captionof{table}{Position of actuators}
	\label{tab:thruster_distance}
	\end{minipage}
\vspace{0.5cm}
\end{minipage}

\section{Power system}
CSE1 is powered with one 12V 12Ah battery on-board. Some of the components require different voltage, and thus some voltage converters are mounted. However, the setup works as it is, and by connecting the battery to the wires, the whole system is powered. A schematic of the power grid is illustrated in Figure \ref{fig: CSE1 power}, and Figure \ref{fig:battery_connected} show a photo of the battery mounted and connected. 
\begin{figure*}[htb!]
\centering
\begin{subfigure}{.45\linewidth}
	\centering
	\includegraphics[height=0.4\paperheight]{fig/CSE1_power}
	\caption{CSE1 power system}
	\label{fig: CSE1 power}
\end{subfigure}
\begin{subfigure}{0.45\linewidth}
	\centering
	\includegraphics[width=\linewidth]{fig/battery_mounted.jpg}
	\caption{Battery mounted and connected}
	\label{fig:battery_connected}
\end{subfigure}
\caption{Battery system}
\end{figure*}

\section{IMU}
CSE1 is equipped with one Inertial Measurement Unit (IMU) from Analog Devices. The sensor mounted on-board is the ADIS16470 and includes a triaxis gyroscope and triaxis accelerometer. The sensor has built-in compensation for bias, alignment and sensitivity, and thus provides accurate measurements over a temperature range of -10 to +75 degrees Celsius. The sampling rate is set to 100 Hz. The most relevant data is presented in Table \ref{tab:IMU_specifications}, and for supplementary information the reader is referred to the data sheet \cite{adis16470}. The coordinate frame of the sensor is illustrated in Figure \ref{fig:IMU_reference_frame}, with positive directions illustrated by arrows. THe the sensor is mounted with a different orientation than the body frame, as can be seen in Figure \ref{fig:IMU_mounted}. Using the \textit{zyx}-convention, the sensor frame has an orientation relative body frame: $(\phi, \theta, \psi) = (\pi, 0, 0)$. Hence, by using the rotation matrix with these values, the measured accelerations and angular rates can be rotated to the body-frame. 
\begin{table}[htb!]\caption{IMU specifications}\label{tab:IMU_specifications}
	\centering
	\begin{tabular}{c|c|c|c|}
		\cline{2-4}
		& \textbf{Parameter} & \textbf{Typical value} & \textbf{Unit}\\ \cline{1-4}
		\multicolumn{1}{|c|}{\multirow{5}{*}{\textbf{Gyroscopes}}} & Dynamic range & $\pm 2000$ & \degree/sec\\ 
		\multicolumn{1}{|c|}{} & Sensitivity & 10 & LSB/\degree/sec\\ 
		\multicolumn{1}{|c|}{} & Bias stability, $\sigma$ & 8 & \degree/hr\\ 
		\multicolumn{1}{|c|}{} & Angular random walk & 0.34 & \degree/$\sqrt{hr}$\\ 
		\multicolumn{1}{|c|}{} & Output noise & 0.17 & \degree/sec rms\\ \cline{1-4}
		
		\multicolumn{1}{|c|}{\multirow{5}{*}{\textbf{Accelerometers}}} & Dynamic range & $\pm 40$ & g\\ 
		\multicolumn{1}{|c|}{} & Sensitivity & 800 & LSB/g\\ 
		\multicolumn{1}{|c|}{} & Bias stability, $\sigma$ & 0.013 & mg\\ 
		\multicolumn{1}{|c|}{} & Velocity random walk & 0.037 & m/sec/$\sqrt{hr}$\\ 
		\multicolumn{1}{|c|}{} & Output noise & 2.3 & mg rms\\ \cline{1-4}
		
		\multicolumn{1}{|c|}{\multirow{1}{*}{\textbf{Power supply}}} & Operating voltage& $3.3 \pm 0.3$ & V\\ \cline{1-4}
	\end{tabular}
\end{table}
\begin{figure}[htb!]
	\centering
	\begin{subfigure}{0.45\linewidth}
		\centering
		\includegraphics[width=1\linewidth]{fig/IMU_reference_frame.png}
		\caption{IMU reference frame from manufacturer}
		\label{fig:IMU_reference_frame}
	\end{subfigure}
	\begin{subfigure}{0.45\linewidth}
		\centering
		\includegraphics[width=0.9\linewidth]{fig/IMU_mounted.jpg}
		\caption{IMU mounted in the vessel}
		\label{fig:IMU_mounted}
	\end{subfigure}
\caption{Inertial Measurement Unit in CSE1}
\end{figure}

\section{Control system}
The on-board control system consists of the following parts:
\begin{itemize}
	% \item a National Instruments compact reconfigurable input/output (cRIO)
	% embedded controller
	\item a Raspberry Pi 4 (RPi) single-board computer
	\item three electronic speed controllers (ESC)
	\item four servos
\end{itemize}
% \subsection{cRIO}
% The model on-board is the cRIO-9024, and it is connected to 4 FPGA modules for analogue and digital I/O:
% \begin{itemize}
% 	\item NI-9215, used for analog input such as measuring voltage
% 	\item NI-9263, used for reading IMU measurements
% 	\item NI-9401, not used
% 	\item NI-9474, used for sending pwm signal
% \end{itemize}
\subsection{RPi}

The Raspberry Pi provides communication 
with the DS4 controller, the servos and the electronic speed controllers.. It works as an embedded system, and once powered it will start searching for the wireless controller. When connection is established, it will continuously send signals to the servos and ESC based on operation mode. To successfully connect the sixaxis controller to the RPi, wait for the Bluetooth dongle to start blinking before pressing the PS-button on the controller. 

\subsection{ESC}
The ESC's are controlled with PWM signals, based on PWM tick signals. Table \ref{tab:pwm_spec} describe the setup for all ESC's on-board CSE1, and Table \ref{tab:pwm_range} gives the pwm signal range for each ESC.
\begin{table}[h!]
	\centering
	\caption{PWM specification for ESC}
	\label{tab:pwm_spec}
	\begin{tabular}{cccc}
		\hline
		\textbf{Initial value} & \textbf{Scaling} & \textbf{Offset} & \textbf{PWM period} [Ticks] \\ \hline
		0 & 100 & 0 & 800.000\\ \hline
	\end{tabular}
\end{table}

\begin{table}[h!]
	\centering
	\caption{PWM ranges for ESC}
	\label{tab:pwm_range}
	\begin{tabular}{cccc}
		\hline
		& \textbf{ESC\_BT}[\%] & \textbf{ESC\_VSP1}[\%] & \textbf{ESC\_VSP2}[\%]\\ \hline
		\textbf{min} & 7.00 & 3.12 & 3.12\\
		\textbf{neutral} & 7.55 & 5.01 & 5.01\\
		\textbf{max} & 8.10 & 6.90 & 6.90\\ \hline
	\end{tabular}
\end{table}

\chapter{Software}
\section{Introduction}

The control system of CSE1 is built around a framework called Robot Operating System. ROS consists of tools, libraries, and conventions that help in building robot applications. This chapter gives a description of vessels software hierarchy. Note that most of this software is ready to use, and alterations in the software described here should not be necessary, unless specified.


\section{Driver setup}

\subsection{Actuator drivers}
To activate the actuators on the vessel, first SSH to the onboard RPi 4 and launch nodelet manager and the CSE actuator driver:
\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ rosrun nodelet nodelet manager __name:=nodelet_manager
  $ rosrun nodelet nodelet load cse_actuator_driver/cse_actuator_driver_nodelet  
  nodelet_manager __name:=cse_actuator_driver
\end{lstlisting}
You should hear a beeping sound if the nodes are succesfully run. 

\subsection{Qualisys drivers}

Next is to launch the Qualisys drivers. These can be found in the Github repository for the MC-Lab. After downloading the package, you can choose to run it from a external computer or on the onboard RPi. To activate it source your workspace, and run the command


\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ roslaunch mocap_qualisys qualisys.launch
\end{lstlisting}

\subsection{IMU-drivers}

To read the data from the IMU, their drivers first have to be read. These are written in C++, but are compatible with a ROS-system written in Python or Matlab. Put the \lstinline{imu_driver} package inside your workspace \textbf{src}-directory and run \lstinline{catkin_make}. After the package is built, first source the bash file and then simply run the package.

\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ source devel/setup.bash
  $ rosrun imu_driver imu_node
\end{lstlisting}

The driver publishes the measurements to the topic \textbf{/imu}. 


\section{ROS with Python}

A number of base python-packages have been made to help build control-system for the CSE1. These can all be found on the \href{https://github.com/NTNU-MCS}{NTNU-MCS} Github repository. Simply download the packages you needed for your own project. This section will provide an outline of different packages, the overall architecture of a ROS workspace as well as the basic knowledge required to run a ROS control system. 

\subsection{Prerequisites and recommended software}

\textbf{Required:}
\begin{itemize}
    \item Python 3.8.3 +
\end{itemize}
\textbf{Recommended:}
\begin{itemize}
    \item Visual Studio Code with the \textbf{Remote SSH} extension. This enables you to SSH directly in to raspberry via VS Code, allowing you to edit files on the pi in the text-editor.
    \item A computer running linux. This is not required as most software will run on the Raspberry Pi, but can be beneficial for testing and visualizing.
\end{itemize}

\subsection{Sourcing your ROS-distribution}

Before you do anything with ROS, you need to source the installation. On the RP this is done automatically, but in case you are working on your own computer the following steps are necessary: 

\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ source /opt/ros/DISTRIBUTION/setup.bash
\end{lstlisting}

\subsection{Building a catkin workspace}

To run ROS-packages we must first define a worspace for them on the Pi. SSH onto the pi and run 

\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ mkdir -p workspace/src; cd workspace
  $ catkin_make
\end{lstlisting}

This should build your catkin workspace, and leave you with three sub-directories; \textbf{build}, \textbf{devel} and \textbf{src}. All ROS-packeges are placed in the \textbf{src}-directory. Everytime you add a package to the workspace, rebuild it using \lstinline{catkin_make}.

\subsection{Running packages}

To run your packages, first make sure you have sourced the \lstinline{setup.bash} file:

\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ source devel/setup.bash
\end{lstlisting}

Then, to run the package use

\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ rosrun <package-name> <node-script>.py
\end{lstlisting}

where <package-name> is the name of the package you want to run, e.g "controller", and the <node-script>.py is the python script that initialisez the rosnode, e.g "controller.py". 

\subsection{Template workspace}

A template workspace consisting of several packages is provided to make developing control systems simpler. The workspace, denoted \textbf{ws\_templates} in the Git-repository, consists of a total of five ROS-packages corresponding two traditional modules in a maneuvering DP-system. These are named:

\begin{itemize}
    \item controller
    \item guidance
    \item observer
    \item thrust\_allocation
    \item simulator 
\end{itemize}

Additionally, there are three packages that provide supporting tools and conventions: 

\begin{itemize}
    \item gain\_server
    \item messages
    \item common\_tools
\end{itemize}

\subsection{Node-structure}

The first four nodes; \textit{controller}, \textit{guidance}, \textit{observer} and \textit{thrust\_allocation} are generic, skeleton packages. Their purpose is to provide a base to build a control-system on, so they only contain the necessary functionality to execute ROS-nodes. The main functionality is left to the user to implement. All the packages follow the exact same structure.

Within every package there is a \textit{src}-directory where a single python script is placed. This is where you will write and call your code. Listing \ref{listing:node} shows an example of a ROS-node that maps the inputs from a PS4 controller to forces in each of CSE1 thrusters. 


\begin{listing}[h]
\inputminted{python}{feedback_ctrl.py}
\caption{Example of a node-file}
\label{listing:node}
\end{listing}

Quickly summarized, you write your functions above the 

\begin{lstlisting}[language=python]
    if__name__ == 'main'
\end{lstlisting}

statement. These functions should then be called in the while loop located inside. The two statements before the while loop are functions for initiating the node, and setting the refresh rate, or frequency, that we want to run the node at. This is predefined in all templates so that you only have to worry about writing the functions and calling them inside the while loop.

Fully fleshed out packages are also available on Github, if one just needs a working control system for experiments without any implementation. These can be found in the folders of \textit{DP\_Lab} and \textit{DP\_Nom} and consist of a backstepping manuevering regulator, a DP-observer, thrust allocation schemes as well as a path-parameterization guidance function. 

\subsection{Simulator}

The simulator package contains a full Model-in-the-loop ROS implementation of the CSE1. It is based of the low-speed dynamics, and can be used for testing the implemented control systems outside of the MC-lab.

The simulator subscribes tp feedback from the topic \textbf{CSEI/u}, to model the signal flow on board the vessel itself. Upon receiving a signal from the topic, it will compute the generalized forces and new position of the vessel.

Note that the model is very simple, and does not take in to account  environmental forces such as current or wind. 


\subsection{Common\_tools package}

As seen in Listing \ref{listing:node}, the templates import from a module called \textbf{common\_tools}. This is where you can find all the tools for publishing and subscribing to the relevant signals in your system, as well as the functions that initialize nodes. The tools are object-oriented, with every relevant signal pertaining to an object in the library. Each object contains methods called publish, and callback. 

Every time a subscriber detects that a new signal is published to its topic, it calls the callback function in our  object, and updates its class variables. You can then retrieve these by using a get-method, or just calling the variable directly through the object.

\begin{lstlisting}[language=python]
  u = u_data.get_data() # Retrieve actuator commands 
  u = u_data.Udata      # Retrieve acutator commands
\end{lstlisting}

The publish method takes an input, and publishes it to the relevant topic.


\begin{lstlisting}[language=python]

 u_data.publish(u) # Publish actuator commands 
\end{lstlisting}

All objects are declared and imported into the relevant code-templates from the \textbf{lib} submodule . Subscriptions to the different topics are all handled inside these classes and the initialization nodes.

It is important that you at any time keep the common\_tools package inside your workspace. The package also contains a submodule called \textbf{math\_tools}. This contains some predefined mathematical functions that may be useful for the project. Rotation matrices and conversions between euler-angles and quaternions are examples of tool you can find here. Feel free to add more functions here as you please, and import them to your nodes. This makes for cleaner and more structured code. 

\subsection{Messages}

While ROS provides many different messaging formats, some times these may be unsuitable to the needs of the system. One might, for example, wish to store the 9 estimated states of the DP observer in a better format than a generic array. That is where custom messages enter. Custom message templates are all stored in the message-package, and can be imported to any other module in the workspace. 

\subsection{The gain\_server package}

To make tuning your controller and observer more effective, tools for dynamic tuning are provided in the form of the ROS-package gain\_server. This allows you to change the gains in real time, rather than having to hard-code the gains and then stopping and starting your simulation every time you want to change them. To activate the node, and GUI use the following steps: 

\begin{itemize}
    \item Make sure you have imported the Gains object from lib.py. It is built like most other objects and contais get-methods for extracting gains, along with callback-functions.
    \item In the \textbf{observerInitNode()} or \textbf{controllerInitNode} uncomment the line starting with \textit{gain\_client}.
    \item To run the node use the command:
    \begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
    $ rosrun gain_server server.py
    \end{lstlisting}
    \textbf{NOTE!} If you use the dynamic tuning, you should always activate this node \textbf{first} or you may experience errors. This is because the observer and controller nodes will expect values to be there when they are not. When the node is activated, the initial gains should be printed to your terminal
    \item In another terminal, activate the GUI: 
     \begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
    $ rosrun rqt_gui rqt_gui -s reconfigure
    \end{lstlisting}
    
    This should open a program that looks like this: 
    
    \begin{figure}[h]
        \centering
        \includegraphics[width=\textwidth]{fig/dynamic-reconfigure(1).png}
        \caption{Tuning GUI}
        \label{fig:tuner}
    \end{figure}
    
    Each field or slider here corresponds to a gain in either the observer or controller. Not all the variables are relevant either. The last to are single float values, while the first six are meant to represent the elements on the diagonal of a $3\times3$-matrix. Change these to tune you controller. 
\end{itemize}

\subsubsection{Parameters}

Currently, the package supports a fixed set of parameters. These are observer injection gains $L1, L2, L3$ as well as the controller gains $Kp, Kd, Ki$, $\mu$ and $Uref$. If other parameters are needed these must be added to the \textbf{gains.cfg} file in the cfg-directory. 

\subsection{Launch files}

As a project progresses, more and more nodes are typically added. The process of activating nodes can therefore become more tedious as the complexity increases. To avoid having to open new command-line windows for every node, we can instead use \textit{launch-files} to activate multiple nodes simultaneously. A launch file is easy to create, and is placed in the \textit{launch} directory of a package.

To run a launch file we use the following command: 

\begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ roslaunch <package_name> my_launchfile.launch  
\end{lstlisting} 

Replace package\_name with the name of the package you placed your launch file in. All launch files have the .launch ending (e.g DP-system.launch). 

\subsection{Usefull ROS-commands}

The following command-line tools are usefull when running a ros system: 

\begin{enumerate}
    \item \begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ rostopic list \end{lstlisting} - Shows a list of all ROS-topics 
  
    \item \begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ rosnode list\end{lstlisting} -
    Shows a list of all active ROS-nodes
     \item \begin{lstlisting}[language=bash,basicstyle=\mlttfamily, breaklines=true]
  $ rostopic echo topic\end{lstlisting} - Prints the messages and data sent to each topic to the command-line window
\end{enumerate}


